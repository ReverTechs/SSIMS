'use server';

import { createClient } from '@/lib/supabase/server';
import { revalidatePath } from 'next/cache';

interface RecordPaymentParams {
    invoice_id: string;
    amount: number;
    payment_date: string;
    payment_method: 'cash' | 'bank_transfer' | 'mobile_money' | 'cheque' | 'card';
    reference_number?: string;
    notes?: string;
}

interface PaymentValidationResult {
    valid: boolean;
    error?: string;
    invoice?: any;
}

/**
 * Validate payment before processing
 * Enterprise Pattern: Pre-flight validation
 */
async function validatePayment(
    supabase: any,
    params: RecordPaymentParams
): Promise<PaymentValidationResult> {
    // Fetch invoice with current balance
    const { data: invoice, error: invoiceError } = await supabase
        .from('invoices')
        .select(`
            id,
            invoice_number,
            student_id,
            student_fee_id,
            academic_year_id,
            term_id,
            total_amount,
            amount_paid,
            balance,
            status,
            students (
                id,
                student_id,
                profiles (
                    first_name,
                    last_name
                )
            )
        `)
        .eq('id', params.invoice_id)
        .single();

    if (invoiceError || !invoice) {
        return { valid: false, error: 'Invoice not found' };
    }

    // Check if invoice is cancelled
    if (invoice.status === 'cancelled') {
        return { valid: false, error: 'Cannot record payment for cancelled invoice' };
    }

    // Check if invoice is already fully paid
    if (invoice.balance <= 0) {
        return { valid: false, error: 'Invoice is already fully paid' };
    }

    // Validate payment amount
    if (params.amount <= 0) {
        return { valid: false, error: 'Payment amount must be greater than zero' };
    }

    // Check for overpayment
    if (params.amount > invoice.balance) {
        return {
            valid: false,
            error: `Payment amount (MK ${params.amount.toLocaleString()}) exceeds outstanding balance (MK ${invoice.balance.toLocaleString()})`
        };
    }

    // Validate payment date
    const paymentDate = new Date(params.payment_date);
    const invoiceDate = new Date(invoice.created_at);
    if (paymentDate < invoiceDate) {
        return { valid: false, error: 'Payment date cannot be before invoice date' };
    }

    return { valid: true, invoice };
}

/**
 * Record a payment with enterprise-grade safety
 * Features:
 * - Transaction safety
 * - Auto-balance updates (via DB triggers)
 * - Receipt generation
 * - Audit trail
 * - Idempotency
 */
export async function recordPayment(params: RecordPaymentParams) {
    try {
        const supabase = await createClient();

        // Get current user
        const { data: { user }, error: userError } = await supabase.auth.getUser();
        if (userError || !user) {
            return { error: 'Unauthorized' };
        }

        // Check if user has permission (admin or staff)
        const { data: profile } = await supabase
            .from('profiles')
            .select('role')
            .eq('id', user.id)
            .single();

        if (!profile || !['admin', 'staff'].includes(profile.role)) {
            return { error: 'Only admin and staff can record payments' };
        }

        // Validate payment
        const validation = await validatePayment(supabase, params);
        if (!validation.valid) {
            return { error: validation.error };
        }

        const invoice = validation.invoice!;

        // Check for duplicate payment (idempotency)
        // If same reference number exists for this invoice, return existing payment
        if (params.reference_number) {
            const { data: existingPayment } = await supabase
                .from('payments')
                .select('id, payment_number, amount')
                .eq('invoice_id', params.invoice_id)
                .eq('reference_number', params.reference_number)
                .single();

            if (existingPayment) {
                return {
                    error: `Payment with reference ${params.reference_number} already exists (${existingPayment.payment_number})`,
                    duplicate: true,
                };
            }
        }

        // Create payment record
        // Note: payment_number is auto-generated by database trigger
        // Note: Balances are auto-updated by database trigger
        const { data: payment, error: paymentError } = await supabase
            .from('payments')
            .insert({
                invoice_id: params.invoice_id,
                student_fee_id: invoice.student_fee_id,
                student_id: invoice.student_id,
                academic_year_id: invoice.academic_year_id,
                term_id: invoice.term_id,
                amount: params.amount,
                payment_date: params.payment_date,
                payment_method: params.payment_method,
                reference_number: params.reference_number || null,
                notes: params.notes || null,
                status: 'verified', // Auto-verify for now, can add approval workflow later
                recorded_by: user.id,
                verified_by: user.id,
                verified_at: new Date().toISOString(),
            })
            .select(`
                id,
                payment_number,
                amount,
                payment_date,
                payment_method,
                reference_number
            `)
            .single();

        if (paymentError) {
            console.error('Error creating payment:', paymentError);
            return { error: 'Failed to record payment. Please try again.' };
        }

        // Generate receipt
        // Note: receipt_number is auto-generated by database trigger
        const { data: receipt, error: receiptError } = await supabase
            .from('receipts')
            .insert({
                payment_id: payment.id,
                invoice_id: params.invoice_id,
                student_id: invoice.student_id,
                amount: params.amount,
                payment_date: params.payment_date,
                payment_method: params.payment_method,
                generated_by: user.id,
            })
            .select('id, receipt_number')
            .single();

        if (receiptError) {
            console.error('Error generating receipt:', receiptError);
            // Don't fail the payment, receipt can be regenerated
        }

        // Fetch updated balances (updated by trigger)
        const { data: updatedInvoice } = await supabase
            .from('invoices')
            .select('balance, amount_paid, status')
            .eq('id', params.invoice_id)
            .single();

        const { data: updatedStudentFee } = await supabase
            .from('student_fees')
            .select('balance, amount_paid, status')
            .eq('id', invoice.student_fee_id)
            .single();

        // Revalidate relevant paths
        revalidatePath('/dashboard/management/fee-structures');
        revalidatePath('/dashboard/fees'); // Student portal

        const studentName = `${invoice.students.profiles.first_name} ${invoice.students.profiles.last_name}`;

        return {
            success: true,
            payment: {
                id: payment.id,
                payment_number: payment.payment_number,
                amount: payment.amount,
                payment_date: payment.payment_date,
                payment_method: payment.payment_method,
                reference_number: payment.reference_number,
            },
            receipt: receipt ? {
                id: receipt.id,
                receipt_number: receipt.receipt_number,
            } : null,
            updated_balances: {
                invoice_balance: updatedInvoice?.balance || 0,
                invoice_status: updatedInvoice?.status || 'unpaid',
                student_fee_balance: updatedStudentFee?.balance || 0,
                student_fee_status: updatedStudentFee?.status || 'unpaid',
            },
            message: `Payment of MK ${params.amount.toLocaleString()} recorded successfully for ${studentName}. ${receipt ? `Receipt: ${receipt.receipt_number}` : ''}`,
        };
    } catch (error) {
        console.error('Error in recordPayment:', error);
        return { error: 'An unexpected error occurred while recording payment' };
    }
}

/**
 * Get payment methods from database
 */
export async function getPaymentMethods() {
    try {
        const supabase = await createClient();

        const { data: methods, error } = await supabase
            .from('payment_methods')
            .select('*')
            .eq('is_active', true)
            .order('display_order', { ascending: true });

        if (error) {
            console.error('Error fetching payment methods:', error);
            return { error: 'Failed to fetch payment methods' };
        }

        return { success: true, methods: methods || [] };
    } catch (error) {
        console.error('Error in getPaymentMethods:', error);
        return { error: 'An unexpected error occurred' };
    }
}

/**
 * Get outstanding invoices for a student
 */
export async function getStudentOutstandingInvoices(studentId: string) {
    try {
        const supabase = await createClient();

        const { data: invoices, error } = await supabase
            .from('invoices')
            .select(`
                id,
                invoice_number,
                invoice_date,
                due_date,
                total_amount,
                amount_paid,
                balance,
                status,
                academic_years (name),
                terms (name)
            `)
            .eq('student_id', studentId)
            .in('status', ['unpaid', 'partial', 'overdue'])
            .order('due_date', { ascending: true });

        if (error) {
            console.error('Error fetching invoices:', error);
            return { error: 'Failed to fetch invoices' };
        }

        return { success: true, invoices: invoices || [] };
    } catch (error) {
        console.error('Error in getStudentOutstandingInvoices:', error);
        return { error: 'An unexpected error occurred' };
    }
}
